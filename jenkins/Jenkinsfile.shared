// jenkins/Jenkinsfile.shared
// This file now accepts parameters passed from the calling Jenkinsfile.

// Define parameters that this shared script expects.
// These will be populated by the 'load' statement in the calling Jenkinsfile.
// Default values are good for testing, but in production they'll be overridden.
def service = 'default-service' // Passed from calling Jenkinsfile
def build = env.BUILD_NUMBER    // Passed from calling Jenkinsfile

pipeline {
  agent any

  // Define global environment variables.
  // `SERVICE` is now explicitly set here from the 'service' parameter,
  // making it available throughout the entire pipeline scope, including post-actions.
  environment {
    SERVICE = "${service}" // Use the 'service' parameter to set the global SERVICE env var
    BUILD_NUMBER = "${build}" // Use the 'build' parameter to set the global BUILD_NUMBER env var
    IMAGE = "tdksfot/${SERVICE}"
    DOCKER_HUB_CREDENTIAL_ID = 'DOCKER_HUB_PASS'
  }

  stages {
    // ... (Your stages remain the same) ...
    stage('Build & Push Image') {
      steps {
        script {
          // ... (Uses SERVICE and BUILD_NUMBER as before, which are now env vars) ...
          dir("${SERVICE}") { // This will now correctly resolve to the env var
            echo "--- Processing service: ${SERVICE} ---"
            if (fileExists('pom.xml')) { /* ... */ }
            else if (fileExists('requirements.txt')) { /* ... */ }
            else { /* ... */ }

            docker.withRegistry('https://registry.hub.docker.com', "${DOCKER_HUB_CREDENTIAL_ID}") {
              echo "INFO: Building and pushing Docker image: ${IMAGE}:${BUILD_NUMBER} to Docker Hub."
              def builtImage = docker.build("${IMAGE}:${BUILD_NUMBER}", '.')
              builtImage.push()
              echo "SUCCESS: Docker image '${IMAGE}:${BUILD_NUMBER}' successfully built and pushed."
            }
          }
        }
      }
    }

    stage('Deploy Helm') {
      steps {
        script {
          def targetNamespace = ""
          if (env.BRANCH_NAME == "develop") { targetNamespace = "dev" }
          else if (env.BRANCH_NAME == "staging") { targetNamespace = "staging" }
          else if (env.BRANCH_NAME == "main") { targetNamespace = "prod" }
          else { echo "INFO: Skipping deployment for branch '${env.BRANCH_NAME}'." ; return }

          echo "INFO: Target Kubernetes Namespace identified: '${targetNamespace}'."
          echo "INFO: Ensuring Kubernetes namespace '${targetNamespace}' exists."
          sh "kubectl create namespace ${targetNamespace} --dry-run=client -o yaml | kubectl apply -f -"

          dir("${SERVICE}/helm/${SERVICE}") { // This will now correctly resolve to the env var
            echo "INFO: Deploying Helm chart for '${SERVICE}' to namespace '${targetNamespace}'..."
            sh """
              helm upgrade --install ${SERVICE} . \\
                --namespace ${targetNamespace} \\
                --set image.repository=${IMAGE} \\
                --set image.tag=${BUILD_NUMBER} \\
                --wait \\
                --timeout 5m
            """
            echo "SUCCESS: Helm deployment for '${SERVICE}' completed successfully in namespace '${targetNamespace}'."
          }
        }
      }
    }
  }

  post {
    failure {
      // Now, SERVICE is an environment variable, so it's accessible.
      echo "ERROR: Pipeline for ${SERVICE} on branch ${env.BRANCH_NAME} failed!"
      mail to: 'devops@monprojet.com',
           subject: "Pipeline Failure: ${SERVICE} - Branch: ${env.BRANCH_NAME}",
           body: """
             The CI/CD pipeline for service '${SERVICE}' on branch '${env.BRANCH_NAME}' has failed.

             Build Number: ${env.BUILD_NUMBER}
             Project Name: ${env.JOB_NAME}
             Full Log: ${env.BUILD_URL}/console

             Please review the Jenkins console output for details.
           """.stripIndent()
    }
    success {
      echo "SUCCESS: Pipeline for ${SERVICE} on branch ${env.BRANCH_NAME} completed successfully!"
    }
  }
}