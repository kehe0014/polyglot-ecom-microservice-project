// jenkins/Jenkinsfile.shared
//
// This file encapsulates the reusable CI/CD pipeline logic for microservices.
// It is designed to be loaded by individual service-specific Jenkinsfiles,
// promoting a 'Don't Repeat Yourself' (DRY) principle for pipeline definitions.
//
// This script expects two parameters to be passed from the calling Jenkinsfile
// via the 'load' statement:
// - `service` (string): The unique name of the microservice (e.g., "user-service").
// - `build` (string): The Jenkins build number for the current execution.
//
// Agent Requirements:
// - The Jenkins controller or an available static agent must have:
//   - Java Development Kit (JDK)
//   - Apache Maven
//   - Python and pip
//   - Docker CLI (and access to a Docker daemon, e.g., user in 'docker' group)
//   - Helm CLI
//   - Kubectl CLI (configured to interact with your Kubernetes cluster, e.g., k3s)

// Define parameters that this shared script expects.
// These will be populated by the 'load' statement in the calling Jenkinsfile.
// Default values are provided as a fallback for testing purposes, but will be overridden.
def service = 'default-service' // Actual value passed from calling Jenkinsfile
def build = env.BUILD_NUMBER    // Actual value passed from calling Jenkinsfile

pipeline {
  // Define the agent where all pipeline stages will execute.
  // 'agent any' means Jenkins will use any available agent, typically the controller itself
  // if no other agents are configured, or the first available static agent.
  agent any

  // --- Global Environment Variables ---
  // These variables are accessible throughout all stages of the pipeline,
  // including post-actions, resolving the MissingPropertyException.
  environment {
    // `SERVICE` is set from the 'service' parameter passed during the `load` call.
    SERVICE = "${service}"

    // `BUILD_NUMBER` is set from the 'build' parameter passed during the `load` call.
    BUILD_NUMBER = "${build}"

    // Constructs the Docker image name using your Docker Hub ID and the service name.
    IMAGE = "tdksfot/${SERVICE}"

    // The Jenkins Credential ID for authenticating with Docker Hub.
    // This is explicitly used as a literal string in `docker.withRegistry` to avoid
    // any Groovy sandbox or variable resolution issues.
    // Ensure 'DOCKER_HUB_PASS' is configured as a 'Secret text' credential in Jenkins.
    // We no longer define a separate env var for its ID here.
  }

  // --- Pipeline Stages ---
  // Each stage represents a distinct phase of the CI/CD process.
  stages {
    // Stage 1: Build Application Artifacts & Push Docker Image
    // This stage handles language-specific compilation/packaging and then
    // constructs and pushes the Docker image to the registry.
    stage('Build & Push Image') {
      steps {
        script {
          // Crucial: Change the current working directory to the specific microservice's
          // root directory. This ensures all file operations (e.g., finding pom.xml,
          // Dockerfile context) are performed correctly relative to the service.
          dir("${SERVICE}") {
            echo "--- Processing service: ${SERVICE} ---"

            // --- Language-Specific Build Preparation ---
            // Detects the project type (Java/Maven or Python) and performs
            // necessary pre-Docker build steps.
            if (fileExists('pom.xml')) {
              echo "INFO: Detected Java/Maven project. Running 'mvn clean package -DskipTests'."
              sh 'mvn clean package -DskipTests'
            } else if (fileExists('requirements.txt')) {
              echo "INFO: Detected Python project. Dependencies will be installed via Dockerfile."
              // For Python, dependencies from requirements.txt are typically installed
              // as part of the Docker image build process itself (e.g., using RUN pip install).
              // No direct `pip install` in the Jenkins agent here is usually required.
            } else {
              // If the project type cannot be determined, terminate the pipeline.
              error "ERROR: Neither 'pom.xml' nor 'requirements.txt' found in '${SERVICE}' directory. Cannot determine build type."
            }

            // --- Docker Build and Push ---
            // Authenticates with Docker Hub using the specified Jenkins credential ID.
            // The `docker.withRegistry` step directly looks up the credential by its ID.
            docker.withRegistry('https://registry.hub.docker.com', 'DOCKER_HUB_PASS') { // <-- Using literal credential ID
              echo "INFO: Building and pushing Docker image: ${IMAGE}:${BUILD_NUMBER} to Docker Hub."
              // The '.' specifies the Docker build context as the current directory
              // (which is '${SERVICE}' due to the preceding 'dir' step).
              def builtImage = docker.build("${IMAGE}:${BUILD_NUMBER}", '.')
              builtImage.push()
              echo "SUCCESS: Docker image '${IMAGE}:${BUILD_NUMBER}' successfully built and pushed."
            }
          }
        }
      }
    }

    // Stage 2: Deploy Application with Helm
    // This stage handles the deployment of the Docker image to Kubernetes using Helm.
    stage('Deploy Helm') {
      steps {
        script {
          def targetNamespace = "" // Variable to hold the target Kubernetes namespace

          // Determine the target Kubernetes namespace based on the Git branch.
          // This implements a simple GitOps-like environment promotion strategy.
          if (env.BRANCH_NAME == "develop") {
            targetNamespace = "dev"
          } else if (env.BRANCH_NAME == "staging") {
            targetNamespace = "staging"
          } else if (env.BRANCH_NAME == "main") {
            targetNamespace = "prod"
          } else {
            // For feature branches or other non-standard branches, skip deployment.
            // Alternatively, one could deploy to a dedicated review environment namespace.
            echo "INFO: Skipping deployment for branch '${env.BRANCH_NAME}'. No matching deployment environment found."
            return // Exit this stage for unhandled branches
          }

          echo "INFO: Target Kubernetes Namespace identified: '${targetNamespace}'."

          // Ensure the target Kubernetes namespace exists.
          // The `--dry-run=client -o yaml | kubectl apply -f -` command is idempotent
          // and will create the namespace only if it doesn't already exist.
          echo "INFO: Ensuring Kubernetes namespace '${targetNamespace}' exists."
          sh "kubectl create namespace ${targetNamespace} --dry-run=client -o yaml | kubectl apply -f -"

          // Crucial: Change directory to the root of the Helm chart for the specific service.
          // This allows Helm commands to use '.' for the chart path.
          dir("${SERVICE}/helm/${SERVICE}") {
            echo "INFO: Deploying Helm chart for '${SERVICE}' to namespace '${targetNamespace}'..."
            // Execute the Helm upgrade --install command.
            // This command is idempotent: it installs if the release doesn't exist,
            // and upgrades if it does.
            // Key parameters:
            // - '.': Refers to the current directory (the Helm chart root).
            // - --namespace: Specifies the target Kubernetes namespace.
            // - --set image.repository: Overrides the image repository in values.yaml.
            // - --set image.tag: Overrides the image tag in values.yaml with BUILD_NUMBER.
            // - --wait: Waits for all release resources to be ready (pods running, services available).
            // - --timeout: Sets a timeout for the --wait operation.
            sh """
              helm upgrade --install ${SERVICE} . \\
                --namespace ${targetNamespace} \\
                --set image.repository=${IMAGE} \\
                --set image.tag=${BUILD_NUMBER} \\
                --wait \\
                --timeout 5m
            """
            echo "SUCCESS: Helm deployment for '${SERVICE}' completed successfully in namespace '${targetNamespace}'."
          }
        }
      }
    }
  }

  // --- Post-build Actions ---
  // Actions to be executed after all stages have completed, regardless of their outcome.
  post {
    // Action to take if any stage in the pipeline fails.
    failure {
      // SERVICE and env.BRANCH_NAME are now available because SERVICE is an env var.
      echo "ERROR: Pipeline for ${SERVICE} on branch ${env.BRANCH_NAME} failed!"
      // Send an email notification for pipeline failure.
      // This relies on Jenkins' global email configuration (Manage Jenkins -> Configure System).
      mail to: 'devops@monprojet.com',
           subject: "Pipeline Failure: ${SERVICE} - Branch: ${env.BRANCH_NAME}",
           body: """
             The CI/CD pipeline for service '${SERVICE}' on branch '${env.BRANCH_NAME}' has failed.

             Build Number: ${env.BUILD_NUMBER}
             Project Name: ${env.JOB_NAME}
             Full Log: ${env.BUILD_URL}/console

             Please review the Jenkins console output for details.
           """.stripIndent()
    }
    // Action to take if the pipeline completes successfully.
    success {
      echo "SUCCESS: Pipeline for ${SERVICE} on branch ${env.BRANCH_NAME} completed successfully!"
    }
    // Add other post-actions as needed (e.g., 'always', 'unstable', 'cleanup').
  }
}
