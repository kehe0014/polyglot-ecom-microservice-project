
// jenkins/Jenkinsfile.shared
//
// This file encapsulates the reusable CI/CD pipeline logic for microservices.
// It is designed to be the primary Jenkinsfile for a parameterized job,
// allowing users to select the target microservice for a build.
//
// Agent Requirements:
// - The Jenkins controller or an available static agent must have:
//   - Java Development Kit (JDK)
//   - Apache Maven
//   - Python and pip
//   - Docker CLI (and access to a Docker daemon, e.g., user in 'docker' group)
//   - Helm CLI
//   - Kubectl CLI (configured to interact with your Kubernetes cluster, e.g., k3s)

pipeline {
  agent any

  // Define parameters for this pipeline.
  // When starting a build, Jenkins will present these options to the user.
  parameters {
    // String parameter for selecting the target microservice.
    // 'defaultValue' ensures 'user-service' is pre-selected.
    string(name: 'TARGET_SERVICE_NAME', defaultValue: 'user-service', description: 'Select the microservice to build and deploy.')

    // Add more parameters as needed, e.g., for build options, deployment environment.
    // choice(name: 'DEPLOY_ENV', choices: ['dev', 'staging', 'prod'], defaultValue: 'dev', description: 'Select the deployment environment.')
  }

  // --- Global Environment Variables ---
  // These variables are accessible throughout all stages of the pipeline,
  // including post-actions.
  environment {
    // The SERVICE variable is now dynamically set from the chosen parameter.
    SERVICE = "${params.TARGET_SERVICE_NAME}"

    // BUILD_NUMBER is an inherent Jenkins environment variable.
    BUILD_NUMBER = env.BUILD_NUMBER

    // Constructs the Docker image name using your Docker Hub ID and the chosen service name.
    IMAGE = "tdksfot/${SERVICE}"

    // The Jenkins Credential ID for authenticating with Docker Hub.
    // This is explicitly used as a literal string in `docker.withRegistry` for robustness.
    // Ensure 'DOCKER_HUB_PASS' is configured as a 'Secret text' credential in Jenkins.
  }

  // --- Pipeline Stages ---
  stages {
    // Stage 1: Build Application Artifacts & Push Docker Image
    // This stage handles language-specific compilation/packaging and then
    // constructs and pushes the Docker image to the registry.
    stage('Build & Push Image') {
      steps {
        script {
          // Crucial: Change the current working directory to the specific microservice's
          // root directory, determined by the chosen parameter.
          dir("${SERVICE}") {
            echo "--- Processing service: ${SERVICE} ---"

            // --- Language-Specific Build Preparation ---
            // Detects the project type (Java/Maven or Python) and performs
            // necessary pre-Docker build steps.
            if (fileExists('pom.xml')) {
              echo "INFO: Detected Java/Maven project. Running 'mvn clean package -DskipTests'."
              sh 'mvn clean package -DskipTests'
            } else if (fileExists('requirements.txt')) {
              echo "INFO: Detected Python project. Dependencies will be installed via Dockerfile."
              // For Python, dependencies from requirements.txt are typically installed
              // as part of the Docker image build process itself (e.g., using RUN pip install).
            } else {
              // If the project type cannot be determined, terminate the pipeline.
              error "ERROR: Neither 'pom.xml' nor 'requirements.txt' found in '${SERVICE}' directory. Cannot determine build type."
            }

            // --- Docker Build and Push ---
            // Authenticates with Docker Hub using the specified Jenkins credential ID.
            docker.withRegistry('https://registry.hub.docker.com', 'DOCKER_HUB_PASS') {
              echo "INFO: Building and pushing Docker image: ${IMAGE}:${BUILD_NUMBER} to Docker Hub."
              // The '.' specifies the Docker build context as the current directory
              // (which is '${SERVICE}' due to the preceding 'dir' step).
              def builtImage = docker.build("${IMAGE}:${BUILD_NUMBER}", '.')
              builtImage.push()
              echo "SUCCESS: Docker image '${IMAGE}:${BUILD_NUMBER}' successfully built and pushed."
            }
          }
        }
      }
    }

    // Stage 2: Deploy Application with Helm
    // This stage handles the deployment of the Docker image to Kubernetes using Helm.
    stage('Deploy Helm') {
      steps {
        script {
          def targetNamespace = "" // Variable to hold the target Kubernetes namespace

          // Determine the target Kubernetes namespace based on the Git branch.
          if (env.BRANCH_NAME == "develop") {
            targetNamespace = "dev"
          } else if (env.BRANCH_NAME == "staging") {
            targetNamespace = "staging"
          } else if (env.BRANCH_NAME == "main") {
            targetNamespace = "prod"
          } else {
            echo "INFO: Skipping deployment for branch '${env.BRANCH_NAME}'. No matching deployment environment found."
            return // Exit this stage for unhandled branches
          }

          echo "INFO: Target Kubernetes Namespace identified: '${targetNamespace}'."
          echo "INFO: Ensuring Kubernetes namespace '${targetNamespace}' exists."
          sh "kubectl create namespace ${targetNamespace} --dry-run=client -o yaml | kubectl apply -f -"

          // Change directory to the Helm chart for the selected service.
          dir("${SERVICE}/helm/${SERVICE}") {
            echo "INFO: Deploying Helm chart for '${SERVICE}' to namespace '${targetNamespace}'..."
            sh """
              helm upgrade --install ${SERVICE} . \\
                --namespace ${targetNamespace} \\
                --set image.repository=${IMAGE} \\
                --set image.tag=${BUILD_NUMBER} \\
                --wait \\
                --timeout 5m
            """
            echo "SUCCESS: Helm deployment for '${SERVICE}' completed successfully in namespace '${targetNamespace}'."
          }
        }
      }
    }
  }

  // --- Post-build Actions ---
  // Actions to be executed after all stages have completed, regardless of their outcome.
  post {
    // Action to take if any stage in the pipeline fails.
    failure {
      echo "ERROR: Pipeline for ${SERVICE} on branch ${env.BRANCH_NAME} failed!"
      // Send an email notification for pipeline failure.
      // This relies on Jenkins' global email configuration (Manage Jenkins -> Configure System).
      mail to: 'devops@monprojet.com',
           subject: "Pipeline Failure: ${SERVICE} - Branch: ${env.BRANCH_NAME}",
           body: """
             The CI/CD pipeline for service '${SERVICE}' on branch '${env.BRANCH_NAME}' has failed.

             Build Number: ${env.BUILD_NUMBER}
             Project Name: ${env.JOB_NAME}
             Full Log: ${env.BUILD_URL}/console

             Please review the Jenkins console output for details.
           """.stripIndent()
    }
    // Action to take if the pipeline completes successfully.
    success {
      echo "SUCCESS: Pipeline for ${SERVICE} on branch ${env.BRANCH_NAME} completed successfully!"
    }
    // Add other post-actions as needed (e.g., 'always', 'unstable', 'cleanup').
  }
}
